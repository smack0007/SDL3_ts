import { ensureDir } from "@std/fs";
import { join } from "@std/path";
import { enums } from "./enums.ts";
import { SRC_PATH, TMP_PATH } from "../../shared/constants.ts";
import { exec } from "../../shared/process.ts";

let output = `#include <stdio.h>
#include <SDL3/SDL.h>
`;

function appendLine(line: string): void {
  output += line + "\n";
}

function appendPrintf(value: string = "", ...args: string[]): void {
  value = value
    .replaceAll("\n", "\\n")
    .replaceAll("\t", "\\t")
    .replaceAll('"', '\\"');

  if (args.length <= 0) {
    value = value.replaceAll("%", "%%");
  }

  let argsString = args.join(", ");

  if (argsString.length > 0) {
    argsString = ", " + argsString;
  }

  appendLine(`printf("${value}\\n"${argsString});`);
}

async function main(): Promise<void> {
  ensureDir(TMP_PATH);

  const result = exec([''])

  // appendLine("int main() {");

  // appendPrintf("// !!!!!");
  // appendPrintf(
  //   "// The file is generated by the codegen. Please do not edit by hand!"
  // );
  // appendPrintf("// !!!!!");
  // appendPrintf();

  // writeOutputEnumValues();

  // appendLine(`return 0;`);
  // appendLine("}");

  // await Deno.writeTextFile(join(TMP_PATH, "codegen.c"), output);

  // const compileCommand = new Deno.Command("gcc", {
  //   args: ["-o", join(TMP_PATH, "codegen"), join(TMP_PATH, "codegen.c")],
  //   stdin: "piped",
  //   stdout: "piped",
  // }).spawn();

  // const compileOutput = await compileCommand.output();

  // if (!compileOutput.success) {
  //   console.error("Failed to compile C program.");
  //   return;
  // }

  // const codegenCommand = new Deno.Command(join(TMP_PATH, "codegen"), {
  //   stdin: "piped",
  //   stdout: "piped",
  // }).spawn();

  // const codegenOutput = await codegenCommand.output();

  // if (!codegenOutput.success) {
  //   console.error("Failed to execute C program.");
  //   return;
  // }

  // await Deno.writeTextFile(
  //   join(SRC_PATH, "SDL", "_native.ts"),
  //   new TextDecoder().decode(codegenOutput.stdout)
  // );
}

function writeOutputEnumValues(): void {
  for (const enumName of enums) {
    appendPrintf("export const %s = %d;", `"${enumName}"`, enumName);
  }
}

try {
  await main();
} catch (error) {
  console.error(error);
  Deno.exitCode = 1;
}
